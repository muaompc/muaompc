"""Integration test for parsing of problem and data files."""

from sys import prefix
import unittest

import numpy as np
import json
from numpy.core.numeric import allclose
from scipy.linalg import block_diag
from numpy.linalg import matrix_power

from muaompc._ldt.parse.prbstruct import DataError
from muaompc import ldt

class TestParseDimensions(unittest.TestCase):
    def test_dat_bad_A(self):
        mpc = ldt.setup_mpc_problem('fixtures/test.prb')
        num = ldt._get_data(mpc, 'fixtures/test_bad_A.dat', safe_mode=True)
        self.assertRaises(DataError, mpc.ddg.generate_data, num, 'xyz')

    def test_bad_Q(self):
        mpc = ldt.setup_mpc_problem('fixtures/test.prb')
        self.assertRaises(ValueError, ldt._get_data, mpc, 'fixtures/test_bad_Q.dat', safe_mode=True)

    def test_dat_R_not_sq(self):
        mpc = ldt.setup_mpc_problem('fixtures/test.prb')
        num = ldt._get_data( mpc, 'fixtures/test_R_not_sq.dat', safe_mode=True)
        self.assertRaises(DataError, mpc.ddg.generate_data, num, 'xyz')

    def test_dat_R_too_big(self):
        mpc = ldt.setup_mpc_problem('fixtures/test.prb')
        num = ldt._get_data( mpc, 'fixtures/test_R_too_big.dat', safe_mode=True)
        self.assertRaises(DataError, mpc.ddg.generate_data, num, 'xyz')

    def test_dat_Q_too_small(self):
        mpc = ldt.setup_mpc_problem('fixtures/test.prb')
        num = ldt._get_data( mpc, 'fixtures/test_Q_too_small.dat', safe_mode=True)
        self.assertRaises(DataError, mpc.ddg.generate_data, num, 'xyz')

    def test_dat_n_too_big(self):
        mpc = ldt.setup_mpc_problem('fixtures/test.prb')
        num = ldt._get_data( mpc, 'fixtures/test_n_too_big.dat', safe_mode=True)
        self.assertRaises(DataError, mpc.ddg.generate_data, num, 'xyz')

    def test_dat_m_too_big(self):
        mpc = ldt.setup_mpc_problem('fixtures/test.prb')
        num = ldt._get_data( mpc, 'fixtures/test_m_too_big.dat', safe_mode=True)
        self.assertRaises(DataError, mpc.ddg.generate_data, num, 'xyz')

    def test_dat_u_bound_size(self):
        mpc = ldt.setup_mpc_problem('fixtures/test.prb')
        num = ldt._get_data( mpc, 'fixtures/test_u_bound_size.dat', safe_mode=True)
        self.assertRaises(DataError, mpc.ddg.generate_data, num, 'xyz')

    def test_dat_state_bound_short(self):
        mpc = ldt.setup_mpc_problem('fixtures/test_state_constr.prb')
        num = ldt._get_data( mpc, 'fixtures/test_state_bound_short.dat', safe_mode=True)
        self.assertRaises(DataError, mpc.ddg.generate_data, num, 'xyz')

    def test_dat_state_bound_long(self):
        mpc = ldt.setup_mpc_problem('fixtures/test_state_constr.prb')
        num = ldt._get_data( mpc, 'fixtures/test_state_bound_long.dat', safe_mode=True)
        self.assertRaises(DataError, mpc.ddg.generate_data, num, 'xyz')

    def test_dat_bad_Kx(self):
        mpc = ldt.setup_mpc_problem('fixtures/test_state_constr.prb')
        num = ldt._get_data( mpc, 'fixtures/test_bad_Kx.dat', safe_mode=True)
        self.assertRaises(DataError, mpc.ddg.generate_data, num, 'xyz')


class TestParseData(unittest.TestCase):
    def setUp(self):
        self.fname = 'xyz'
        self.prefix = 'mpc'
        self.fixtures = 'fixtures/'

    def tearDown(self):
        pass

    def test_dat_input_constr_ok(self):
        prbname = 'test'
        prbpath = self.fixtures + prbname + '.prb'
        mpc = ldt.setup_mpc_problem(prbpath)
        num = ldt._get_data(mpc, 'fixtures/test_input_constr_ok.dat', safe_mode=True)
        mpc.ddg.generate_data(num, self.fname)
        H = self._load_H(prbname)
        HH = self._form_H(num)
        scale = max(np.linalg.eigvals(HH))
        np.testing.assert_allclose(HH, H*scale) 

    def test_dat_state_constr_ok(self):
        prbname = 'test_state_constr'
        prbpath = self.fixtures + prbname + '.prb'
        mpc = ldt.setup_mpc_problem(prbpath)
        num = ldt._get_data(mpc, 'fixtures/test_state_constr_ok.dat', safe_mode=True)
        mpc.ddg.generate_data(num, self.fname)
        H = self._load_H(prbname)
        HH = self._form_H(num)
        np.testing.assert_allclose(HH, H) 

    def _form_H(self, num):
        N = num['N']
        qq = [num['Q']]*(N-1)
        qq.append(num['P'])
        QQ = block_diag(*qq)
        RR = block_diag(*[num['R']]*N)
        A = num['A']
        B = num['B']
        (n, m) = B.shape
        BB = np.zeros([n*N, m*N])
        BB[:n, :m] = B[:]
        for i in range(1, N):
            AB = BB[(i-1)*n:i*n, 0:m]
            AAB = A @ AB
            BB[i*n:(i+1)*n, 0:m] = AAB[:]
            BBi = BB[(i-1)*n:i*n, 0:-m]
            BB[i*n:(i+1)*n, m:] = BBi

        H = BB.T @ QQ @ BB + RR
        return H

    def _load_H(self, prbname):
        # load the Hessian matrix as generated by muaompc
        path = '%s_%s/data/%s/%s%s.json' % (self.prefix, prbname, self.fname,
        self.prefix, self.fname)
        with open(path) as f:
            d = json.load(f)

        Hp = d['pmetric']['H']['fac0']

        H = np.array(Hp['data'])
        H = H.reshape((Hp['rows'], Hp['cols']))
        # muaompc returns the cost function's Hessian matrix divided by a factor
        try:
            scale = d['Linv']*2  # state constraints problems (ALM+FGM)
        except KeyError:
            scale = 1.  # H has been divided by max eigenval (FGM)
        return H / scale


if __name__ == '__main__':
    unittest.main()
